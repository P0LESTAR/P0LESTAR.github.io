---
title: CVE-2025-68664 (Langchain) 분석

author: P0LESTAR
date: 2025-12-28 00:01:01 +0800
categories: [CVE, 1-day분석]
tags: [CVE, CVE-2025-68664, LangChain, 1-day분석]
#pin: true
sitemap:
  changefreq: monthly
  priority: 0.5
---

## 개요

LangChain 프레임워크의 데이터 처리 과정에서 심각한 보안 취약점이 발견되었습니다. 

이 취약점은 데이터를 문자열로 변환하는 직렬화(`dumps`, `dumpd`) 및 이를 다시 객체로 복구하는 역직렬화(`load`, `loads`) 과정에서 발생합니다.

핵심 원인은 사용자로부터 전달된 자유 형식의 딕셔너리 데이터를 역직렬화할 때, LangChain 내부에서 객체 식별자로 사용하는 특정 키를 이스케이프 처리하지 않았다는 점에 있습니다. 

이로 인해 공격자가 조작한 데이터가 단순한 정보가 아닌, 시스템에 의해 실행되는 유효한 LangChain 객체로 오인되는 현상이 발생합니다.

>해당 취약점은 1.2.5, 0.3.81 버전에서 패치되었습니다
{: .prompt-info }

---

## 핵심 매커니즘

이 취약점의 기술적 본질은 데이터 평면(Data Plane)과 제어 평면(Control Plane)의 분리 실패에 있습니다. 

>LangChain은 복잡한 객체 구조를 JSON 형태로 직렬화하기 위해 내부적인 규약을 사용하는데, 이 과정에서 발생하는 식별자 처리 미비가 위협의 시작점입니다.
{: .prompt-info }

### 1. LangChain의 객체 식별 규약
- LangChain은 직렬화된 데이터가 단순한 딕셔너리인지, 아니면 특정 클래스로 복구해야 할 객체인지를 구분하기 위해 lc라는 키를 사용합니다.

- `lc`: 1: 이 데이터는 LangChain의 직렬화 프로토콜 버전 1을 따르는 객체임을 선언합니다.

- `type`: 객체의 유형을 정의합니다 (예: constructor, secret, not_implemented).

- `id`: 해당 객체를 생성하기 위해 참조해야 할 클래스의 경로를 나타냅니다.

>정상적인 상황에서 `dumps()` 함수는 사용자의 일반 데이터에 포함된 lc 키를 마스킹하거나 이스케이프하여 역직렬화 시 명령어로 해석되지 않도록 보호해야 합니다.
{: .prompt-info }

### 2. 이스케이프 누락과 로직 오염
문제는 공격자가 의도적으로 lc 키를 포함한 딕셔너리를 입력값으로 주입하더라도, 해당 함수들은 이를 일반 문자열 데이터로 취급하여 무력화하지 않고 그대로 직렬화 결과물에 포함시킵니다. (역직렬화 오염이 발생 가능)

사용자 입력 단계에서 공격 코드가 담긴 딕셔너리`{"lc": 1, ...}`가 주입됩니다.

이후 시스템이 load() 또는 loads()를 호출하면, 역직렬화기는 해당 지점을 단순 데이터가 아닌 **'복구해야 할 유효한 LangChain 객체'**로 인식합니다.

### 3. 데이터가 명령어로 승격되는 과정
이 메커니즘을 통해 공격자는 단순히 텍스트를 전달하는 것을 넘어, 시스템 내부의 로직을 직접 호출할 수 있는 권한을 획득하게 됩니다.

```python

# 공격자가 주입한 악성 구조체 예시
attacker_injected_data = {
    "lc": 1,
    "type": "secret",
    "id": ["OPENAI_API_KEY"]
}
```

위 구조체가 역직렬화 과정을 거치면, LangChain의 load 함수는 이를 해석하여 실제 환경 변수에서 해당 키값을 찾아와 결과물에 채워 넣습니다. 

즉, 정적이어야 할 데이터가 시스템의 자원에 접근하는 동적인 명령어로 승격되는 것입니다.


<br>

---

## 보안 패치
LangChain은 load() 및 loads() 함수의 기본 동작 방식을 근본적으로 변경했습니다. 

단순히 `lc` 키를 처리하는 로직을 수정하는 것에 그치지 않고, 시스템이 신뢰할 수 없는 데이터를 다룰 때 발생할 수 있는 잠재적 위험을 최소화하기 위해 세 가지 주요 보안 계층을 도입했습니다.

### 1. 허용 목록(Allowlist) 기반의 객체 제한

기존의 역직렬화 프로세스는 LangChain 생태계 내의 광범위한 클래스들을 제약 없이 복구할 수 있었습니다. 패치 이후에는 `allowed_objects` 매개변수가 도입되어 역직렬화 가능한 클래스를 엄격하게 제한합니다.

기본값 설정: 현재 기본값은 `core`로 설정되어 있으며, 이는 `langchain_core` 내부에 정의된 핵심 객체들로 역직렬화 범위를 한정합니다.

>보안 효과: 공격자가 임의의 클래스 구조를 주입하더라도, 허용 목록에 포함되지 않은 클래스라면 인스턴스화가 거부됩니다. 이는 신뢰되지 않은 네임스페이스의 코드가 실행되는 것을 원천 차단합니다.

### 2. 환경 변수 자동 로드 중단

과거 LangChain은 역직렬화 과정에서 Secret 타입의 객체를 만나면 시스템의 환경 변수에서 값을 자동으로 조회하여 채워 넣었습니다. 

이번 패치에서는 이 기능의 기본 설정을 변경했습니다.

`secrets_from_env` 변경: 해당 옵션의 기본값이 True에서 False로 변경되었습니다.

>보안 효과: 공격자가 {"type": "secret", "id": ["..."]} 구조를 주입하는 데 성공하더라도, 시스템은 더 이상 환경 변수에서 민감한 정보를 가져오지 않습니다. 

명시적으로 이 옵션을 활성화하지 않는 한 API 키 유출과 같은 정보 탈취 공격은 무력화됩니다.

### 3. 템플릿 엔진의 기본 차단

Jinja2와 같은 템플릿 엔진은 동적 프롬프트 생성에 유용하지만, 동시에 임의 코드 실행(RCE)의 통로가 될 위험이 큽니다.

`init_validator` 도입: `default_init_validator`가 기본적으로 적용되어, 역직렬화 과정에서 Jinja2 템플릿이 포함된 객체의 생성을 차단합니다.

>보안 효과: 템플릿 주입을 통한 고차원적인 공격 시도를 사전에 방지합니다. 만약 Jinja2 사용이 반드시 필요한 신뢰할 수 있는 환경이라면 사용자가 수동으로 검증 로직을 해제해야 합니다.

### 4. 직렬화 단계의 이스케이프 강화

load() 측의 방어와 더불어, 근본적인 원인이었던 dumps()와 dumpd() 함수에서도 개선이 이루어졌습니다. 

>사용자가 제어하는 일반 딕셔너리 데이터를 직렬화할 때, 내부 구조와 충돌할 수 있는 'lc' 키 패턴을 인식하고 이를 안전하게 처리하는 로직이 추가되어 데이터가 명령어로 오인될 여지를 제거했습니다.











## 참고
<https://www.cvedetails.com/cve/CVE-2025-68664/>

<https://github.com/langchain-ai/langchain/security/advisories/GHSA-c67j-w6g6-q2cm>